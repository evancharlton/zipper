{"version":3,"sources":["state/kommune.ts","state/geojson.ts","state/map.ts","ForkMe/ForkMe.tsx","KommuneList/KommuneList.tsx","LoadingLayer/LoadingLayer.tsx","MapDisplay/MapDisplay.tsx","SearchLayer/SearchInput/SearchInput.tsx","SearchLayer/SearchLayer.tsx","Sidebar/Sidebar.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["kommuneState","atom","key","default","geojsonState","type","features","pending","geojsonFiltered","selector","get","state","query","geo","copy","filter","feature","properties","navn","find","sprak","toLowerCase","startsWith","geojsonFeatures","map","lokalid","names","name","id","sort","nameA","nameB","localeCompare","geojsonLoaded","mapState","ForkMe","href","KommuneList","useRecoilValue","setKommuneQuery","useSetRecoilState","onClick","useCallback","className","LoadingLayer","mapLoaded","dataLoaded","mapboxgl","accessToken","NORWAY","MapDisplay","geojson","setMapLoaded","useState","setMap","mapDivRef","useRef","onSetDivRef","ref","current","createdMap","Map","container","style","bounds","on","addSource","data","addLayer","source","layout","paint","useEffect","getSource","setData","height","SearchInput","placeholder","value","onChange","onChangeHandler","e","target","backgroundColor","fontSize","border","borderRadius","padding","color","SearchLayer","useRecoilState","kommuneQuery","Sidebar","children","App","setGeojson","fetch","process","then","resp","json","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.ec4a3ac2.chunk.js","sourcesContent":["import { atom } from 'recoil';\n\nexport const kommuneState = atom({\n  key: 'kommune-query',\n  default: '',\n});\n","import { atom, selector } from 'recoil';\nimport { kommuneState } from './kommune';\n\nexport const geojsonState = atom({\n  key: 'geojson',\n  default: {\n    type: 'FeatureCollection' as const,\n    features: [],\n    pending: true,\n  },\n});\n\nconst filter = (geo: any, query: string) => {\n  const copy = {\n    ...geo,\n  };\n\n  copy.features = geo.features.filter((feature: any) => {\n    const {\n      properties: { navn: names },\n    } = feature;\n    // navn is an array because there can be multiple names\n    return (names as any[]).find(({ navn, sprak }: any) => {\n      return (\n        sprak === 'nor' && navn.toLowerCase().startsWith(query.toLowerCase())\n      );\n    });\n  });\n\n  return copy;\n};\n\nexport const geojsonFiltered = selector({\n  key: 'geojson-filtered',\n  get: ({ get }) => {\n    const state = get(geojsonState);\n    const query = get(kommuneState);\n    if (query) {\n      return filter(state, query);\n    }\n\n    return state;\n  },\n});\n\nexport type SimpleFeature = {\n  name: string;\n  id: number;\n};\n\nexport const geojsonFeatures = selector({\n  key: 'geojson-features',\n  get: ({ get }) => {\n    const filtered = get(geojsonFiltered);\n    const features: SimpleFeature[] = filtered.features.map((feature: any) => {\n      const { lokalid, navn: names } = feature.properties;\n      const result =\n        names.find(({ sprak }: any) => sprak === 'nor') ?? names[0];\n      return {\n        name: result.navn,\n        id: lokalid,\n      };\n    });\n    return features.sort(({ name: nameA }, { name: nameB }) =>\n      nameA.localeCompare(nameB)\n    );\n  },\n});\n\nexport const geojsonLoaded = selector({\n  key: 'geojson-loaded',\n  get: ({ get }) => {\n    const { pending } = get(geojsonState);\n    return pending !== true;\n  },\n});\n","import { atom } from 'recoil';\n\nexport const mapState = atom({\n  key: 'mapbox-map',\n  default: false,\n});\n","import React from 'react';\nimport './ForkMe.css';\n\nconst ForkMe = () => {\n  return (\n    <span id=\"forkongithub\">\n      <a href=\"https://github.com/evancharlton/zipper\">Fork me on GitHub</a>\n    </span>\n  );\n};\n\nexport default ForkMe;\n","import React, { useCallback } from 'react';\nimport { useRecoilValue, useSetRecoilState } from 'recoil';\nimport { geojsonFeatures, kommuneState } from '../state';\nimport { SimpleFeature } from '../state/geojson';\nimport './KommuneList.css';\n\nconst KommuneList = () => {\n  const features = useRecoilValue(geojsonFeatures);\n  const setKommuneQuery = useSetRecoilState(kommuneState);\n\n  const onClick = useCallback(\n    (name: string) => () => {\n      setKommuneQuery(name);\n    },\n    [setKommuneQuery]\n  );\n\n  return (\n    <div className=\"kommunes\">\n      <ul className=\"kommune-list\">\n        {features.map(({ name, id }: SimpleFeature) => {\n          return (\n            <li key={id} className=\"kommune-name\">\n              <button onClick={onClick(name)}>{name}</button>\n            </li>\n          );\n        })}\n      </ul>\n    </div>\n  );\n};\n\nexport default KommuneList;\n","import React from 'react';\nimport { useRecoilValue } from 'recoil';\nimport { geojsonLoaded, mapState } from '../state';\nimport './LoadingLayer.css';\n\nconst LoadingLayer = () => {\n  const mapLoaded = useRecoilValue(mapState);\n  const dataLoaded = useRecoilValue(geojsonLoaded);\n\n  if (mapLoaded && dataLoaded) {\n    return null;\n  }\n\n  return (\n    <div className=\"loading-layer\">\n      <div className=\"lds-dual-ring\" />\n      {!mapLoaded && <h3>Loading map&hellip;</h3>}\n      {!dataLoaded && <h3>Loading data&hellip;</h3>}\n    </div>\n  );\n};\n\nexport default LoadingLayer;\n","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { useSetRecoilState, useRecoilValue } from 'recoil';\nimport mapboxgl, { LngLatBoundsLike } from 'mapbox-gl';\nimport 'mapbox-gl/dist/mapbox-gl.css';\nimport { geojsonFiltered, mapState } from '../state';\n\nmapboxgl.accessToken =\n  'pk.eyJ1IjoiZXZhbmNoYXJsdG9uIiwiYSI6ImNrZ205b2diejAyazQzNW9jajdud2J2NnMifQ.LwYUjS8uxTr2DxYoKoGykA';\n\nconst NORWAY: LngLatBoundsLike = [\n  [4, 57],\n  [33, 72],\n];\n\nconst SOURCE_ID = 'geojson-id' as const;\nconst LAYER_ID = 'layer-id' as const;\n\nconst MapDisplay = () => {\n  const geojson = useRecoilValue(geojsonFiltered);\n  const setMapLoaded = useSetRecoilState(mapState);\n\n  const [map, setMap] = useState<mapboxgl.Map | null>(null);\n  const mapDivRef = useRef<HTMLDivElement | null>(null);\n\n  const onSetDivRef = useCallback(\n    (ref) => {\n      mapDivRef.current = ref;\n\n      const createdMap = new mapboxgl.Map({\n        container: ref,\n        style: 'mapbox://styles/mapbox/dark-v10',\n        bounds: NORWAY,\n      });\n\n      const onMapLoaded = () => {\n        createdMap.addSource(SOURCE_ID, {\n          type: 'geojson',\n          data: {\n            type: 'FeatureCollection' as const,\n            features: [],\n          },\n        });\n\n        createdMap.addLayer({\n          id: LAYER_ID,\n          type: 'line',\n          source: SOURCE_ID,\n          layout: {\n            'line-join': 'round',\n            'line-cap': 'round',\n          },\n          paint: {\n            'line-color': '#fff',\n            'line-width': 2,\n            'line-opacity': 0.25,\n          },\n        });\n        setMap(createdMap);\n        setMapLoaded(true);\n      };\n\n      createdMap.on('load', onMapLoaded);\n    },\n    [mapDivRef, setMapLoaded]\n  );\n\n  // When the geojson data changes, update the map.\n  useEffect(() => {\n    if (!geojson || !map) {\n      return;\n    }\n\n    (map.getSource(SOURCE_ID) as mapboxgl.GeoJSONSource).setData(geojson);\n  }, [geojson, map]);\n\n  return (\n    <div\n      ref={onSetDivRef}\n      style={{\n        height: '100%',\n      }}\n    ></div>\n  );\n};\n\nexport default MapDisplay;\n","import React, { useCallback } from 'react';\n\ntype Props = Pick<HTMLInputElement, 'placeholder' | 'value'> & {\n  onChange: (value: string) => void;\n};\n\nconst SearchInput = ({ placeholder, value, onChange }: Props) => {\n  const onChangeHandler = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      onChange(e.target.value);\n    },\n    [onChange]\n  );\n\n  return (\n    <input\n      style={{\n        backgroundColor: 'transparent',\n        fontSize: 20,\n        border: '1px solid #fff3',\n        borderRadius: 5,\n        padding: 5,\n        color: '#fffa',\n      }}\n      onChange={onChangeHandler}\n      placeholder={placeholder}\n      value={value}\n    />\n  );\n};\n\nexport default SearchInput;\n","import React from 'react';\nimport { useRecoilState } from 'recoil';\nimport SearchInput from './SearchInput';\nimport { kommuneState } from '../state';\n\nconst SearchLayer = () => {\n  const [kommuneQuery, setKommuneQuery] = useRecoilState(kommuneState);\n\n  return (\n    <SearchInput\n      placeholder=\"Kommune\"\n      value={kommuneQuery}\n      onChange={setKommuneQuery}\n    />\n  );\n};\n\nexport default SearchLayer;\n","import React from 'react';\nimport './Sidebar.css';\n\ntype Props = {\n  children: React.ReactNode[];\n};\n\nconst Sidebar = ({ children }: Props) => {\n  return <div className=\"sidebar\">{children}</div>;\n};\n\nexport default Sidebar;\n","import React, { useEffect } from 'react';\nimport { useSetRecoilState, useRecoilValue } from 'recoil';\nimport { geojsonState, mapState } from './state';\nimport ForkMe from './ForkMe';\nimport KommuneList from './KommuneList';\nimport LoadingLayer from './LoadingLayer';\nimport MapDisplay from './MapDisplay';\nimport SearchLayer from './SearchLayer';\nimport Sidebar from './Sidebar';\n\nimport './App.css';\n\nconst App = () => {\n  const setGeojson = useSetRecoilState(geojsonState);\n  const map = useRecoilValue(mapState);\n\n  useEffect(() => {\n    if (!map) {\n      return;\n    }\n\n    fetch(`${process.env.PUBLIC_URL}/kommune.json`)\n      .then((resp) => resp.json())\n      .then((json) => setGeojson(json));\n  }, [map, setGeojson]);\n\n  return (\n    <>\n      <MapDisplay />\n      <Sidebar>\n        <SearchLayer />\n        <KommuneList />\n      </Sidebar>\n      <LoadingLayer />\n      <ForkMe />\n    </>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { RecoilRoot } from 'recoil';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <RecoilRoot>\n      <App />\n    </RecoilRoot>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}