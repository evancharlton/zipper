{"version":3,"sources":["constants.ts","state/filter.ts","state/geojson.ts","state/map.ts","ForkMe/ForkMe.tsx","LoadingLayer/LoadingLayer.tsx","MapDisplay/MapDisplay.tsx","SearchLayer/SearchInput/SearchInput.tsx","SearchLayer/SearchLayer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["NORWAY","nummerState","atom","key","default","nummerPattern","selector","get","out","length","PLACEHOLDER_GEOJSON","type","features","payloadState","payloadLoaded","level","geoResults","geojsonData","results","name","map","polygon","properties","geometry","coordinates","BOUNDS","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","geoBounds","reduce","acc","westA","southA","eastA","northA","westB","southB","eastB","northB","Math","max","min","cap","xy","west","south","east","north","x","y","mapState","ForkMe","id","href","LoadingLayer","mapLoaded","useRecoilValue","dataLoaded","className","mapboxgl","accessToken","MapDisplay","geojson","setMapLoaded","useSetRecoilState","bounds","useState","setMap","mapDivRef","useRef","onSetDivRef","useCallback","ref","current","createdMap","Map","container","style","on","addSource","data","addLayer","source","layout","paint","useEffect","getSource","setData","fitBounds","height","SearchInput","placeholder","value","onChange","onChangeHandler","e","target","replace","onKeyDown","currentTarget","lastDigit","charAt","String","backgroundColor","fontSize","border","borderRadius","padding","color","maxLength","inputMode","autoFocus","SearchLayer","useRecoilState","nummerQuery","setNummerQuery","App","setPayload","fetch","process","then","resp","json","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.356f1369.chunk.js","sourcesContent":["import { LngLatBoundsLike } from 'mapbox-gl';\n\nexport const NORWAY: LngLatBoundsLike = [\n  [4, 57],\n  [33, 72],\n];\n","import { atom, selector } from 'recoil';\n\nexport const nummerState = atom({\n  key: 'nummer-query',\n  default: '',\n});\n\nexport const nummerPattern = selector({\n  key: 'nummer-query-pattern',\n  get: ({ get }) => {\n    const query = get(nummerState);\n    let out = query;\n    while (out.length < 4) {\n      out += 'x';\n    }\n    return out;\n  },\n});\n","import { LngLatBoundsLike } from 'mapbox-gl';\nimport { atom, selector } from 'recoil';\nimport { NORWAY } from '../constants';\nimport { nummerPattern, nummerState } from './filter';\n\ntype XYCoordinate = [number, number];\ntype Polygon = XYCoordinate[];\n\ntype DataLookup = { [query: string]: Polygon[] } & { level?: number };\n\nconst PLACEHOLDER_GEOJSON = {\n  type: 'FeatureCollection' as const,\n  features: [],\n};\n\nexport const payloadState = atom({\n  key: 'data-payload',\n  default: {} as DataLookup,\n});\n\nexport const payloadLoaded = selector({\n  key: 'data-payload-loaded',\n  get: ({ get }) => {\n    const payload = get(payloadState);\n    return (payload.level ?? 0) > 2;\n  },\n});\n\nexport const geoResults = selector({\n  key: 'geo-results',\n  get: ({ get }) => {\n    const payload = get(payloadState);\n    const pattern = get(nummerPattern);\n\n    return payload[pattern] ?? [];\n  },\n});\n\nexport const geojsonData = selector({\n  key: 'geojson-filtered',\n  get: ({ get }) => {\n    const results = get(geoResults);\n    if (results.length === 0) {\n      return PLACEHOLDER_GEOJSON;\n    }\n\n    return {\n      type: 'FeatureCollection' as const,\n      name: 'Zipper' as const,\n      features: results.map((polygon) => ({\n        type: 'Feature' as const,\n        properties: {},\n        geometry: {\n          type: 'Polygon' as const,\n          coordinates: [polygon],\n        },\n      })),\n    };\n  },\n});\n\ntype nn = [[number, number], [number, number]];\n\nconst BOUNDS: nn = [\n  [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER] as [number, number],\n  [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER] as [number, number],\n];\n\nconst cap = (\n  [[westA, southA], [eastA, northA]]: nn,\n  [[westB, southB], [eastB, northB]]: nn\n): LngLatBoundsLike => {\n  return [\n    [Math.max(westA, westB), Math.max(southA, southB)],\n    [Math.min(eastA, eastB), Math.min(northA, northB)],\n  ];\n};\n\nexport const geoBounds = selector<LngLatBoundsLike | null>({\n  key: 'geo-bounds',\n  get: ({ get }) => {\n    const query = get(nummerState);\n    if (!query) {\n      return NORWAY;\n    }\n    const results: Polygon[] = get(geoResults);\n    if (results.length === 0) {\n      return null;\n    }\n\n    // @ts-ignore\n    const boundingBox: LngLatBoundsLike = results.reduce((acc, polygon) => {\n      const polygonBounds: nn = polygon.reduce(\n        ([[west, south], [east, north]], xy) => {\n          const [x, y] = xy as [number, number];\n          return [\n            [Math.max(west, x), Math.max(south, y)],\n            [Math.min(east, x), Math.min(north, y)],\n          ];\n        },\n        BOUNDS\n      );\n      // @ts-ignore\n      return cap(acc, polygonBounds);\n    }, BOUNDS as nn);\n\n    return boundingBox;\n  },\n});\n","import { atom } from 'recoil';\n\nexport const mapState = atom({\n  key: 'mapbox-map',\n  default: false,\n});\n","import React from 'react';\nimport './ForkMe.css';\n\nconst ForkMe = () => {\n  return (\n    <span id=\"forkongithub\">\n      <a href=\"https://github.com/evancharlton/zipper\">Fork me on GitHub</a>\n    </span>\n  );\n};\n\nexport default ForkMe;\n","import React from 'react';\nimport { useRecoilValue } from 'recoil';\nimport { mapState, payloadLoaded } from '../state';\nimport './LoadingLayer.css';\n\nconst LoadingLayer = () => {\n  const mapLoaded = useRecoilValue(mapState);\n  const dataLoaded = useRecoilValue(payloadLoaded);\n\n  if (mapLoaded && dataLoaded) {\n    return null;\n  }\n\n  return (\n    <div className=\"loading-layer\">\n      <div className=\"lds-dual-ring\" />\n      {!mapLoaded && <h3>Loading map&hellip;</h3>}\n      {!dataLoaded && <h3>Loading data&hellip;</h3>}\n    </div>\n  );\n};\n\nexport default LoadingLayer;\n","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { useSetRecoilState, useRecoilValue } from 'recoil';\nimport mapboxgl, { LngLatBoundsLike } from 'mapbox-gl';\nimport 'mapbox-gl/dist/mapbox-gl.css';\nimport { geoBounds, geojsonData, mapState } from '../state';\nimport { NORWAY } from '../constants';\n\nmapboxgl.accessToken =\n  'pk.eyJ1IjoiZXZhbmNoYXJsdG9uIiwiYSI6ImNrZ205b2diejAyazQzNW9jajdud2J2NnMifQ.LwYUjS8uxTr2DxYoKoGykA';\n\nconst SOURCE_ID = 'geojson-id' as const;\nconst LAYER_ID = 'layer-id' as const;\n\nconst MapDisplay = () => {\n  const geojson = useRecoilValue(geojsonData);\n  const setMapLoaded = useSetRecoilState(mapState);\n  const bounds = useRecoilValue(geoBounds);\n\n  const [map, setMap] = useState<mapboxgl.Map | null>(null);\n  const mapDivRef = useRef<HTMLDivElement | null>(null);\n\n  const onSetDivRef = useCallback(\n    (ref) => {\n      mapDivRef.current = ref;\n\n      const createdMap = new mapboxgl.Map({\n        container: ref,\n        style: 'mapbox://styles/mapbox/dark-v10',\n        bounds: NORWAY,\n      });\n\n      const onMapLoaded = () => {\n        createdMap.addSource(SOURCE_ID, {\n          type: 'geojson',\n          data: {\n            type: 'FeatureCollection' as const,\n            features: [],\n          },\n        });\n\n        createdMap.addLayer({\n          id: LAYER_ID,\n          type: 'line',\n          source: SOURCE_ID,\n          layout: {\n            'line-join': 'round',\n            'line-cap': 'round',\n          },\n          paint: {\n            'line-color': '#fff',\n            'line-width': 2,\n            'line-opacity': 0.25,\n          },\n        });\n        setMap(createdMap);\n        setMapLoaded(true);\n      };\n\n      createdMap.on('load', onMapLoaded);\n    },\n    [mapDivRef, setMapLoaded]\n  );\n\n  // When the geojson data changes, update the map.\n  useEffect(() => {\n    if (!geojson || !map) {\n      return;\n    }\n\n    (map.getSource(SOURCE_ID) as mapboxgl.GeoJSONSource).setData(geojson);\n  }, [geojson, map]);\n\n  useEffect(() => {\n    if (!map) {\n      return;\n    }\n\n    if (bounds) {\n      map.fitBounds(bounds as LngLatBoundsLike);\n    }\n  }, [map, bounds]);\n\n  return (\n    <div\n      ref={onSetDivRef}\n      style={{\n        height: '100%',\n      }}\n    ></div>\n  );\n};\n\nexport default MapDisplay;\n","import React, { useCallback } from 'react';\n\ntype Props = Pick<HTMLInputElement, 'placeholder' | 'value'> & {\n  onChange: (value: string) => void;\n};\n\nconst SearchInput = ({ placeholder, value, onChange }: Props) => {\n  const onChangeHandler = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      onChange(e.target.value.replace(/[^0-9]/, ''));\n    },\n    [onChange]\n  );\n\n  const onKeyDown = useCallback(\n    (e: React.KeyboardEvent<HTMLInputElement>) => {\n      let value = e.currentTarget.value;\n      if (!value) {\n        return;\n      }\n\n      let lastDigit = +value.charAt(value.length - 1);\n      switch (e.key) {\n        case 'ArrowUp': {\n          lastDigit += 1;\n          break;\n        }\n        case 'ArrowDown': {\n          lastDigit -= 1;\n          break;\n        }\n      }\n      lastDigit = (lastDigit + 10) % 10;\n\n      value = value.replace(/[0-9]$/, String(lastDigit));\n      onChange(String(value));\n    },\n    [onChange]\n  );\n\n  return (\n    <input\n      style={{\n        backgroundColor: 'transparent',\n        fontSize: 20,\n        border: '1px solid #fff3',\n        borderRadius: 5,\n        padding: 5,\n        color: '#fffa',\n      }}\n      maxLength={4}\n      inputMode=\"numeric\"\n      onKeyDown={onKeyDown}\n      onChange={onChangeHandler}\n      placeholder={placeholder}\n      value={value}\n      autoFocus\n    />\n  );\n};\n\nexport default SearchInput;\n","import React from 'react';\nimport { useRecoilState } from 'recoil';\nimport SearchInput from './SearchInput';\nimport { nummerState } from '../state';\nimport './SearchLayer.css';\n\nconst SearchLayer = () => {\n  const [nummerQuery, setNummerQuery] = useRecoilState(nummerState);\n\n  return (\n    <div className=\"search-area\">\n      <SearchInput\n        placeholder=\"Postnummer\"\n        value={nummerQuery}\n        onChange={setNummerQuery}\n      />\n    </div>\n  );\n};\n\nexport default SearchLayer;\n","import React, { useEffect } from 'react';\nimport { useSetRecoilState, useRecoilValue } from 'recoil';\nimport { mapState, payloadState } from './state';\nimport ForkMe from './ForkMe';\nimport LoadingLayer from './LoadingLayer';\nimport MapDisplay from './MapDisplay';\nimport SearchLayer from './SearchLayer';\n\nimport './App.css';\n\nconst App = () => {\n  const setPayload = useSetRecoilState(payloadState);\n  const map = useRecoilValue(mapState);\n\n  useEffect(() => {\n    if (!map) {\n      return;\n    }\n\n    const get = (level: number) =>\n      fetch(`${process.env.PUBLIC_URL}/clustered-${level}.json`)\n        .then((resp) => resp.json())\n        .then((json) =>\n          setPayload((current) => ({ ...current, ...json, level }))\n        );\n\n    get(0)\n      .then(() => get(1))\n      .then(() => get(2))\n      .then(() => get(3))\n      .then(() => get(4));\n  }, [map, setPayload]);\n\n  return (\n    <>\n      <MapDisplay />\n      <SearchLayer />\n      <LoadingLayer />\n      <ForkMe />\n    </>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { RecoilRoot } from 'recoil';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <RecoilRoot>\n      <App />\n    </RecoilRoot>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}