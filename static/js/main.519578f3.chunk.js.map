{"version":3,"sources":["state/filter.ts","state/geojson.ts","state/map.ts","ForkMe/ForkMe.tsx","LoadingLayer/LoadingLayer.tsx","MapDisplay/MapDisplay.tsx","SearchLayer/SearchInput/SearchInput.tsx","SearchLayer/SearchLayer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["kommuneState","atom","key","default","nummerState","geojsonState","type","features","pending","geojsonFiltered","selector","get","state","kommuneQuery","geo","query","copy","filter","feature","properties","navn","find","sprak","toLowerCase","startsWith","kommuneFilter","nummerQuery","postnummer","nummerFilter","geojsonLoaded","map","lokalid","names","name","id","sort","nameA","nameB","localeCompare","value","index","arr","mapState","ForkMe","href","LoadingLayer","mapLoaded","useRecoilValue","dataLoaded","className","mapboxgl","accessToken","NORWAY","MapDisplay","geojson","setMapLoaded","useSetRecoilState","useState","setMap","mapDivRef","useRef","onSetDivRef","useCallback","ref","current","createdMap","Map","container","style","bounds","on","addSource","data","addLayer","source","layout","paint","useEffect","getSource","setData","height","SearchInput","placeholder","onChange","onChangeHandler","e","target","replace","onKeyDown","currentTarget","lastDigit","charAt","length","String","backgroundColor","fontSize","border","borderRadius","padding","color","maxLength","inputMode","autoFocus","SearchLayer","useRecoilState","setNummerQuery","App","setGeojson","fetch","process","then","resp","json","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.519578f3.chunk.js","sourcesContent":["import { atom } from 'recoil';\n\nexport const kommuneState = atom({\n  key: 'kommune-query',\n  default: '',\n});\n\nexport const nummerState = atom({\n  key: 'nummer-query',\n  default: '',\n});\n","import { atom, selector } from 'recoil';\nimport { kommuneState, nummerState } from './filter';\n\nexport const geojsonState = atom({\n  key: 'geojson',\n  default: {\n    type: 'FeatureCollection' as const,\n    features: [],\n    pending: true,\n  },\n});\n\nconst kommuneFilter = (geo: any, query: string) => {\n  const copy = {\n    ...geo,\n  };\n\n  copy.features = geo.features.filter((feature: any) => {\n    const {\n      properties: { navn: names },\n    } = feature;\n    // navn is an array because there can be multiple names\n    return (names as any[]).find(({ navn, sprak }: any) => {\n      return (\n        sprak === 'nor' && navn.toLowerCase().startsWith(query.toLowerCase())\n      );\n    });\n  });\n\n  return copy;\n};\n\nconst nummerFilter = (geo: any, query: string) => {\n  const copy = {\n    ...geo,\n  };\n\n  copy.features = geo.features.filter((feature: any) => {\n    return feature.properties.postnummer.startsWith(query);\n  });\n\n  return copy;\n};\n\nexport const geojsonFiltered = selector({\n  key: 'geojson-filtered',\n  get: ({ get }) => {\n    const state = get(geojsonState);\n    const kommuneQuery = get(kommuneState);\n    if (kommuneQuery) {\n      return kommuneFilter(state, kommuneQuery);\n    }\n\n    const nummerQuery = get(nummerState);\n    if (nummerQuery) {\n      return nummerFilter(state, nummerQuery);\n    }\n\n    return state;\n  },\n});\n\nexport type SimpleFeature = {\n  name: string;\n  id: number;\n};\n\nexport const geojsonFeatures = selector({\n  key: 'geojson-features',\n  get: ({ get }) => {\n    const filtered = get(geojsonFiltered);\n    const features: SimpleFeature[] = filtered.features.map((feature: any) => {\n      const { lokalid = 0, navn: names = [] } = feature.properties;\n      const result = names.find(({ sprak }: any) => sprak === 'nor') ??\n        names[0] ?? { navn: '404' };\n      return {\n        name: result.navn,\n        id: lokalid,\n      };\n    });\n    return features\n      .sort(({ name: nameA }, { name: nameB }) => nameA.localeCompare(nameB))\n      .filter((value, index, arr) => {\n        if (index === 0) {\n          return true;\n        }\n        return value.name !== arr[index - 1].name;\n      });\n  },\n});\n\nexport const geojsonLoaded = selector({\n  key: 'geojson-loaded',\n  get: ({ get }) => {\n    const { pending } = get(geojsonState);\n    return pending !== true;\n  },\n});\n","import { atom } from 'recoil';\n\nexport const mapState = atom({\n  key: 'mapbox-map',\n  default: false,\n});\n","import React from 'react';\nimport './ForkMe.css';\n\nconst ForkMe = () => {\n  return (\n    <span id=\"forkongithub\">\n      <a href=\"https://github.com/evancharlton/zipper\">Fork me on GitHub</a>\n    </span>\n  );\n};\n\nexport default ForkMe;\n","import React from 'react';\nimport { useRecoilValue } from 'recoil';\nimport { geojsonLoaded, mapState } from '../state';\nimport './LoadingLayer.css';\n\nconst LoadingLayer = () => {\n  const mapLoaded = useRecoilValue(mapState);\n  const dataLoaded = useRecoilValue(geojsonLoaded);\n\n  if (mapLoaded && dataLoaded) {\n    return null;\n  }\n\n  return (\n    <div className=\"loading-layer\">\n      <div className=\"lds-dual-ring\" />\n      {!mapLoaded && <h3>Loading map&hellip;</h3>}\n      {!dataLoaded && <h3>Loading data&hellip;</h3>}\n    </div>\n  );\n};\n\nexport default LoadingLayer;\n","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { useSetRecoilState, useRecoilValue } from 'recoil';\nimport mapboxgl, { LngLatBoundsLike } from 'mapbox-gl';\nimport 'mapbox-gl/dist/mapbox-gl.css';\nimport { geojsonFiltered, mapState } from '../state';\n\nmapboxgl.accessToken =\n  'pk.eyJ1IjoiZXZhbmNoYXJsdG9uIiwiYSI6ImNrZ205b2diejAyazQzNW9jajdud2J2NnMifQ.LwYUjS8uxTr2DxYoKoGykA';\n\nconst NORWAY: LngLatBoundsLike = [\n  [4, 57],\n  [33, 72],\n];\n\nconst SOURCE_ID = 'geojson-id' as const;\nconst LAYER_ID = 'layer-id' as const;\n\nconst MapDisplay = () => {\n  const geojson = useRecoilValue(geojsonFiltered);\n  const setMapLoaded = useSetRecoilState(mapState);\n\n  const [map, setMap] = useState<mapboxgl.Map | null>(null);\n  const mapDivRef = useRef<HTMLDivElement | null>(null);\n\n  const onSetDivRef = useCallback(\n    (ref) => {\n      mapDivRef.current = ref;\n\n      const createdMap = new mapboxgl.Map({\n        container: ref,\n        style: 'mapbox://styles/mapbox/dark-v10',\n        bounds: NORWAY,\n      });\n\n      const onMapLoaded = () => {\n        createdMap.addSource(SOURCE_ID, {\n          type: 'geojson',\n          data: {\n            type: 'FeatureCollection' as const,\n            features: [],\n          },\n        });\n\n        createdMap.addLayer({\n          id: LAYER_ID,\n          type: 'line',\n          source: SOURCE_ID,\n          layout: {\n            'line-join': 'round',\n            'line-cap': 'round',\n          },\n          paint: {\n            'line-color': '#fff',\n            'line-width': 2,\n            'line-opacity': 0.25,\n          },\n        });\n        setMap(createdMap);\n        setMapLoaded(true);\n      };\n\n      createdMap.on('load', onMapLoaded);\n    },\n    [mapDivRef, setMapLoaded]\n  );\n\n  // When the geojson data changes, update the map.\n  useEffect(() => {\n    if (!geojson || !map) {\n      return;\n    }\n\n    (map.getSource(SOURCE_ID) as mapboxgl.GeoJSONSource).setData(geojson);\n  }, [geojson, map]);\n\n  return (\n    <div\n      ref={onSetDivRef}\n      style={{\n        height: '100%',\n      }}\n    ></div>\n  );\n};\n\nexport default MapDisplay;\n","import React, { useCallback } from 'react';\n\ntype Props = Pick<HTMLInputElement, 'placeholder' | 'value'> & {\n  onChange: (value: string) => void;\n};\n\nconst SearchInput = ({ placeholder, value, onChange }: Props) => {\n  const onChangeHandler = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      onChange(e.target.value.replace(/[^0-9]/, ''));\n    },\n    [onChange]\n  );\n\n  const onKeyDown = useCallback(\n    (e: React.KeyboardEvent<HTMLInputElement>) => {\n      let value = e.currentTarget.value;\n      if (!value) {\n        return;\n      }\n\n      let lastDigit = +value.charAt(value.length - 1);\n      switch (e.key) {\n        case 'ArrowUp': {\n          lastDigit += 1;\n          break;\n        }\n        case 'ArrowDown': {\n          lastDigit -= 1;\n          break;\n        }\n      }\n      lastDigit = (lastDigit + 10) % 10;\n\n      value = value.replace(/[0-9]$/, String(lastDigit));\n      onChange(String(value));\n    },\n    [onChange]\n  );\n\n  return (\n    <input\n      style={{\n        backgroundColor: 'transparent',\n        fontSize: 20,\n        border: '1px solid #fff3',\n        borderRadius: 5,\n        padding: 5,\n        color: '#fffa',\n      }}\n      maxLength={4}\n      inputMode=\"numeric\"\n      onKeyDown={onKeyDown}\n      onChange={onChangeHandler}\n      placeholder={placeholder}\n      value={value}\n      autoFocus\n    />\n  );\n};\n\nexport default SearchInput;\n","import React from 'react';\nimport { useRecoilState } from 'recoil';\nimport SearchInput from './SearchInput';\nimport { nummerState } from '../state';\nimport './SearchLayer.css';\n\nconst SearchLayer = () => {\n  const [nummerQuery, setNummerQuery] = useRecoilState(nummerState);\n\n  return (\n    <div className=\"search-area\">\n      <SearchInput\n        placeholder=\"Postnummer\"\n        value={nummerQuery}\n        onChange={setNummerQuery}\n      />\n    </div>\n  );\n};\n\nexport default SearchLayer;\n","import React, { useEffect } from 'react';\nimport { useSetRecoilState, useRecoilValue } from 'recoil';\nimport { geojsonState, mapState } from './state';\nimport ForkMe from './ForkMe';\nimport LoadingLayer from './LoadingLayer';\nimport MapDisplay from './MapDisplay';\nimport SearchLayer from './SearchLayer';\n\nimport './App.css';\n\nconst App = () => {\n  const setGeojson = useSetRecoilState(geojsonState);\n  const map = useRecoilValue(mapState);\n\n  useEffect(() => {\n    if (!map) {\n      return;\n    }\n\n    fetch(`${process.env.PUBLIC_URL}/postnummer.min.json`)\n      .then((resp) => resp.json())\n      .then((json) => setGeojson(json));\n  }, [map, setGeojson]);\n\n  return (\n    <>\n      <MapDisplay />\n      <SearchLayer />\n      <LoadingLayer />\n      <ForkMe />\n    </>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { RecoilRoot } from 'recoil';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <RecoilRoot>\n      <App />\n    </RecoilRoot>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}